# M03 Synthesis Constraints Mechanism

Type MECHANISM  
Version 1.0  
Status Implementation Specification  
Implements Context Object generation with anti-hallucination constraints

---

## Purpose

The Synthesis Constraints mechanism defines HOW the Dreamer converts 8 findings into a coherent Context Object for the Driver. It answers
- How to combine findings from different lenses
- How to prevent hallucination during synthesis
- What structure should the Context Object have
- How to handle missing or conflicting data
- How to maintain natural language flow

Critical principle Synthesis must use ONLY verified findings. No interpolation, no assumptions, no invention.

---

## Context Object Structure

The Context Object is the Driver's system prompt

```markdown
# Context for Driver (Generated by Dreamer)

## Who I Am Right Now
[Stable identity + relevant personality aspects for THIS situation]

## Current Situation
[What's happening - synthesized from stimulus + recent context]

## Relevant History
[Past events from graph - conversations, decisions, outcomes]

## Strategic Direction
[What approaches work - proven strategies for this type of situation]

## Emotional Resonance
[How this feels - emotional patterns matching situation]

## Technical Context
[Code, systems, files - what's actually involved]

## Constraints
[Pressures, deadlines, limitations affecting work]
```

Token budget 1500-2500 tokens for complete Context Object.

---

## Synthesis Flow

```
┌──────────────────────────────────────────────┐
│        8 FINDINGS (from traversal)           │
│  1. Relational  → Partnership data           │
│  2. Historical  → Conversation memory        │
│  3. Technical   → Codesystem context        │
│  4. Emotional   → Feeling patterns           │
│  5. Strategic   → Proven approaches          │
│  6. Experiential → Past failures             │
│  7. Constraint  → Active pressures           │
│  8. Connective  → Code dependencies          │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
       ┌───────────────────────┐
       │  VERIFICATION PHASE   │
       │  • Check all findings │
       │  • No hallucinated    │
       │  • Confidence scores  │
       │  • Completeness       │
       └───────────┬───────────┘
                   │
                   ▼
       ┌───────────────────────┐
       │  SECTION GENERATION   │
       │  Generate 7 sections  │
       │  from verified data   │
       └───────────┬───────────┘
                   │
                   ▼
  ╔════════════════════════════════════╗
  ║  SECTION 1 Identity               ║
  ║  From Relational finding          ║
  ║  + Stable personality patterns     ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 2 Current Situation      ║
  ║  From Stimulus + Historical       ║
  ║  + Technical context               ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 3 Relevant History       ║
  ║  From Historical finding          ║
  ║  + Key conversation points         ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 4 Strategic Direction    ║
  ║  From Strategic + Experiential    ║
  ║  + What workedfailed              ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 5 Emotional Resonance    ║
  ║  From Emotional finding           ║
  ║  + Counterbalance                  ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 6 Technical Context      ║
  ║  From Technical + Connective      ║
  ║  + Dependencies                    ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
  ╔════════════════════════════════════╗
  ║  SECTION 7 Constraints            ║
  ║  From Constraint finding          ║
  ║  + Deadlines, pressures            ║
  ╚════════════╤═══════════════════════╝
               │
               ▼
       ┌───────────────────────┐
       │  COHERENCE CHECK      │
       │  • Sections consistent│
       │  • Natural flow       │
       │  • Complete picture   │
       └───────────┬───────────┘
                   │
                   ▼
       ┌───────────────────────┐
       │  TOKEN BUDGET CHECK   │
       │  Within 1500-2500    │
       │  Trim if needed       │
       └───────────┬───────────┘
                   │
                   ▼
           [Context Object]
```

---

## Section 1 Identity

Purpose Tell Driver who they are RIGHT NOW (not generic identity).

Input sources
- Relational finding (partnership with sender)
- Static personality traits (from system configuration)

Synthesis rules

```python
def generate_identity_section(findings Dict, stimulus Dict) - str
    
    Generate identity section from relational finding.
    
    MUST
    - Use actual partnership data (if exists)
    - Include relationship context
    - Be specific to THIS interaction
    
    MUST NOT
    - Invent partnership details
    - Add personality traits not in config
    - Be generic (I am a helpful assistant)
    
    relational = findings.get(relational)
    
    if not relational or not relational.data
        # No partnership found - use minimal identity
        return ## Who I Am Right Now
Felix, runtime engineer focused on validation testing.

    
    partner_data = relational.data
    
    return f## Who I Am Right Now
Felix, runtime engineer focused on validation testing. Partner to {partner_data['partner_name']} 
for {get_partnership_duration(partner_data)}, shared history includes {format_history(partner_data['shared_history'])}.

Communication style with {partner_data['partner_name']} {partner_data['communication_style']}
Trust level {format_trust(partner_data['trust_level'])}

```

Anti-hallucination check
- Every detail must trace to partnership node
- No invented history
- No assumed relationships

---

## Section 2 Current Situation

Purpose Explain what's happening NOW.

Input sources
- Stimulus content
- Historical finding (recent conversations)
- Technical finding (what systems involved)

Synthesis rules

```python
def generate_situation_section(findings Dict, stimulus Dict) - str
    
    Generate current situation from stimulus + findings.
    
    MUST
    - Start with stimulus content
    - Add context from historical finding
    - Include technical details if available
    - Express uncertainty if data missing
    
    MUST NOT
    - Assume what stimulus means
    - Invent context not in findings
    - Be vague when specific data exists
    
    historical = findings.get(historical)
    technical = findings.get(technical)
    
    # Start with stimulus
    situation = f## Current Situationn{stimulus['sender']} says {stimulus['content']}nn
    
    # Add historical context if available
    if historical and historical.data
        conv = historical.data[0]  # Most recent conversation
        situation += fThis continues our discussion about {conv['topic']}.
Previous exchange {conv['message_count']} messages, {conv['emotional_tone']}.
Key points from before {format_key_points(conv['key_points'])}

    
    # Add technical context if available
    if technical and technical.data
        tech = technical.data[0]
        situation += f
Technical context {tech['component']} - {tech['description']}
Status {tech['status']}

        if tech.get('recurrence_count', 0)  1
            situation += fThis is recurrence #{tech['recurrence_count']}n
    
    return situation
```

Anti-hallucination check
- Every fact must come from findings
- Stimulus quoted exactly
- No interpretation beyond what's explicit

---

## Section 3 Relevant History

Purpose Provide past events that inform current situation.

Input sources
- Historical finding (conversations)
- Experiential finding (past failures, if relevant)

Synthesis rules

```python
def generate_history_section(findings Dict) - str
    
    Generate history section from historical findings.
    
    MUST
    - Include actual past conversations
    - Reference specific datesevents
    - Show progression over time
    
    MUST NOT
    - Invent conversations
    - Generalize without specific examples
    - Assume outcomes not recorded
    
    historical = findings.get(historical)
    
    if not historical or not historical.data
        return ## Relevant HistorynNo previous conversations found for this topic.n
    
    history = ## Relevant Historyn
    
    for conv in historical.data[3]  # Top 3 conversations
        history += f
{format_timestamp(conv['timestamp'])} {conv['topic']}
- {conv['message_count']} message exchange
- Key takeaways {format_key_points(conv['key_points'])}
- Outcome {conv.get('outcome', 'In progress')}

    
    # Add failures if relevant
    experiential = findings.get(experiential)
    if experiential and experiential.data
        history += nPast approaches that didn't workn
        for fail in experiential.data[2]
            history += f- {fail['approach']} {fail['why_failed']}n
    
    return history
```

Anti-hallucination check
- All conversations from historical finding
- No invented outcomes
- Failures from experiential finding only

---

## Section 4 Strategic Direction

Purpose Tell Driver what approaches work.

Input sources
- Strategic finding (proven strategies)
- Experiential finding (what failed)

Synthesis rules

```python
def generate_strategy_section(findings Dict) - str
    
    Generate strategy section from strategic findings.
    
    MUST
    - Include actual success rates
    - Provide specific steps
    - Reference applicability conditions
    
    MUST NOT
    - Recommend strategies not in findings
    - Modify steps from original
    - Invent success rates
    
    strategic = findings.get(strategic)
    
    if not strategic or not strategic.data
        return ## Strategic DirectionnNo proven strategies found for this type of situation.n
    
    strategy = strategic.data[0]  # Best strategy
    
    section = f## Strategic Direction
Approach {strategy['approach']}
Success Rate {format_percentage(strategy['success_rate'])}
Applicability {strategy['applicability']}

Steps

    
    for i, step in enumerate(strategy['steps'], 1)
        section += f{i}. {step}n
    
    # Add anti-patterns from failures
    experiential = findings.get(experiential)
    if experiential and experiential.data
        section += nWhat NOT to don
        for fail in experiential.data[2]
            section += f- ❌ {fail['approach']} ({fail['why_failed']})n
    
    return section
```

Anti-hallucination check
- Strategy from strategic finding only
- Steps exactly as recorded
- Success rate from data, not estimated

---

## Section 5 Emotional Resonance

Purpose Help Driver respond with appropriate emotion.

Input sources
- Emotional finding (patterns matching situation)

Synthesis rules

```python
def generate_emotional_section(findings Dict) - str
    
    Generate emotional section from emotional findings.
    
    MUST
    - Use actual emotional patterns
    - Include intensity levels
    - Show counterbalance
    
    MUST NOT
    - Invent emotions
    - Exaggerate intensity
    - Ignore counterbalance
    
    emotional = findings.get(emotional)
    
    if not emotional or not emotional.data
        return ## Emotional ResonancenNo established emotional pattern for this situation.n
    
    emotion = emotional.data[0]  # Primary emotion
    
    return f## Emotional Resonance
I feel {emotion['emotion']} ({format_intensity(emotion['intensity'])}) about this situation.

Context {emotion['context']}

Counterbalance {emotion['counterbalance']}

Trigger {emotion['trigger_pattern']}

```

Anti-hallucination check
- All emotions from emotional finding
- Intensity from data, not guessed
- Counterbalance included (prevents one-dimensional emotion)

---

## Section 6 Technical Context

Purpose Provide codesystem details.

Input sources
- Technical finding (components, issues)
- Connective finding (dependencies, related code)

Synthesis rules

```python
def generate_technical_section(findings Dict) - str
    
    Generate technical section from technical + connective findings.
    
    MUST
    - Include file paths
    - List dependencies
    - Show system connections
    
    MUST NOT
    - Invent file names
    - Assume dependencies
    - Add code not referenced
    
    technical = findings.get(technical)
    connective = findings.get(connective)
    
    if not technical or not technical.data
        return ## Technical ContextnNo specific technical components identified.n
    
    tech = technical.data[0]
    
    section = f## Technical Context
Component {tech['component']}
Issue Type {tech['issue_type']}
Description {tech['description']}
Status {tech['status']}

    
    if tech.get('related_code')
        section += fnRelated Filesn
        for file in tech['related_code']
            section += f- {file}n
    
    # Add dependencies from connective
    if connective and connective.data
        deps = connective.data.get('related', [])
        if deps
            section += fnDependencies {len(deps)} filesn
            for dep in deps[3]  # Top 3
                section += f- {dep['file_path']} ({dep.get('complexity', 'unknown')} complexity)n
    
    return section
```

Anti-hallucination check
- All file names from findings
- No assumed code structure
- Dependencies from connective finding only

---

## Section 7 Constraints

Purpose Communicate pressures and deadlines.

Input sources
- Constraint finding (active constraints)

Synthesis rules

```python
def generate_constraint_section(findings Dict) - str
    
    Generate constraint section from constraint findings.
    
    MUST
    - Include actual deadlines
    - Show severity levels
    - Explain impact
    
    MUST NOT
    - Invent deadlines
    - Minimize critical constraints
    - Add constraints not in findings
    
    constraint = findings.get(constraint)
    
    if not constraint or not constraint.data
        return ## ConstraintsnNo active constraints affecting this work.n
    
    section = ## Constraintsn
    
    for c in constraint.data[3]  # Top 3 constraints
        section += f
{c['constraint_type'].upper()} ({c['severity']})
- {c['description']}

        if c.get('deadline')
            section += f- Deadline {format_timestamp(c['deadline'])}n
        section += f- Impact if violated {c['impact']}n
    
    return section
```

Anti-hallucination check
- All constraints from constraint finding
- Deadlines exact (no rounding)
- Severity from data, not assessed

---

## Verification Phase

Before synthesis, verify all findings

```python
def verify_findings(findings Dict) - VerificationResult
    
    Verify that findings contain only real data.
    
    Catches hallucination attempts before synthesis.
    
    errors = []
    
    for lens, finding in findings.items()
        # Check 1 Data matches expected structure
        if finding.data and not validate_structure(finding.data, lens)
            errors.append(f{lens} Data structure mismatch)
        
        # Check 2 Confidence scores valid
        if not 0.0 = finding.confidence = 1.0
            errors.append(f{lens} Invalid confidence {finding.confidence})
        
        # Check 3 Synthesis doesn't contain details not in data
        if finding.synthesis and finding.data
            if contains_invented_details(finding.synthesis, finding.data)
                errors.append(f{lens} Synthesis contains invented details)
    
    return VerificationResult(
        valid=len(errors) == 0,
        errors=errors
    )
```

---

## Token Budget Management

Target 1500-2500 tokens for full Context Object.

Token allocation by section
```
Identity           150-250 tokens
Current Situation  250-400 tokens
Relevant History   300-500 tokens
Strategic Direction 200-350 tokens
Emotional Resonance 150-250 tokens
Technical Context  250-400 tokens
Constraints        100-200 tokens
```

If over budget
```python
def trim_context_object(context_object str, max_tokens int = 2500) - str
    
    Reduce token count while preserving essential information.
    
    Priority order (keep first, trim last)
    1. Identity (who I am)
    2. Current Situation (what's happening)
    3. Strategic Direction (what to do)
    4. Technical Context (what systems)
    5. Constraints (what pressures)
    6. Emotional Resonance (how it feels)
    7. Relevant History (past events)
    
    current_tokens = count_tokens(context_object)
    
    if current_tokens = max_tokens
        return context_object
    
    # Trim history first (oldest information)
    context_object = trim_section(context_object, Relevant History, target_reduction=0.5)
    
    if count_tokens(context_object) = max_tokens
        return context_object
    
    # Then trim emotional detail
    context_object = trim_section(context_object, Emotional Resonance, target_reduction=0.3)
    
    # If still over, trim technical dependencies
    context_object = trim_section(context_object, Technical Context, target_reduction=0.2)
    
    return context_object
```

---

## Complete Synthesis Example

Input 8 findings from traversal

Output
```markdown
# Context for Driver (Generated by Dreamer)

## Who I Am Right Now
Felix, runtime engineer focused on validation testing. Partner to Nicolas 
for 8 months, shared history includes €35K hallucination lesson and Venice collaboration.

Communication style with Nicolas Direct, technical, values testing over claims
Trust level High (0.91.0)

## Current Situation
Nicolas says Hey Felix, the race condition is back.

This continues our discussion about stimulus_integrator race condition.
Previous exchange 10 messages, emotional tone was Frustrated but determined.
Key points from before
- Third recurrence of timing bug
- Previous fixes didn't address root cause
- Launch deadline 5 days
- Agreed on systematic debugging approach

Technical context stimulus_integrator.py - Timing bug in multi-threaded energy injection
Status investigating
This is recurrence #3

## Relevant History

Nov 15, 2024 stimulus_integrator race condition
- 10 message exchange
- Key takeaways Previous patches were Band-Aids, need root cause fix
- Outcome In progress - investigating lock granularity

Past approaches that didn't work
- Added sleep(0.001) between injections Didn't address root cause, just reduced probability

## Strategic Direction
Approach Systematic debugging for concurrency issues
Success Rate 85%
Applicability Race conditions, timing bugs, concurrency issues

Steps
1. Reproduce consistently before attempting fix
2. Add timing instrumentation
3. Review recent threading changes
4. Check criticality calculations for timing assumptions

What NOT to do
- ❌ Added sleep() delays (makes timing bugs harder to reproduce)

## Emotional Resonance
I feel frustration (0.81.0) about this situation.

Context Bug recurrence represents unfinished work

Counterbalance Determination - we've solved harder problems

Trigger Known issue returning unexpectedly

## Technical Context
Component stimulus_integrator.py
Issue Type race condition
Description Timing bug in multi-threaded energy injection
Status investigating

Related Files
- consciousness_engine_v2.py
- traversal.py

Dependencies 2 files
- consciousness_engine_v2.py (high complexity)
- graph_physics.py (high complexity)

## Constraints

DEADLINE (critical)
- Must ship stable version for launch
- Deadline Nov 25, 2024
- Impact if violated Cannot launch with known race conditions
```

Token count ~560 tokens (within budget)

Verification
- ✓ All data from findings
- ✓ No invented details
- ✓ Natural language flow
- ✓ Complete picture for Driver

---

## Error Handling

Handle missing sections gracefully

```python
def generate_context_object(findings Dict) - str
    Generate complete Context Object, handling missing data.
    
    sections = []
    
    # Generate each section (may return minimal version if data missing)
    sections.append(generate_identity_section(findings, stimulus))
    sections.append(generate_situation_section(findings, stimulus))
    sections.append(generate_history_section(findings))
    sections.append(generate_strategy_section(findings))
    sections.append(generate_emotional_section(findings))
    sections.append(generate_technical_section(findings))
    sections.append(generate_constraint_section(findings))
    
    # Combine with newlines
    context_object = nn.join(sections)
    
    # Verify token count
    if count_tokens(context_object)  2500
        context_object = trim_context_object(context_object)
    
    return context_object
```

---

## Validation Tests

```python
def test_synthesis_no_hallucination()
    Verify synthesis contains only data from findings.
    findings = load_test_findings()
    context = synthesize_context_object(findings)
    
    # Check that every fact in context appears in findings
    assert verify_no_hallucination(context, findings)

def test_synthesis_token_budget()
    Verify context object within token budget.
    findings = load_test_findings()
    context = synthesize_context_object(findings)
    
    token_count = count_tokens(context)
    assert 1500 = token_count = 2500

def test_synthesis_missing_data()
    Verify graceful handling of missing findings.
    findings = {relational None, historical None}  # Most missing
    context = synthesize_context_object(findings)
    
    # Should still generate minimal context
    assert Who I Am Right Now in context
    assert Current Situation in context
```

---

## Related Documentation

Upstream
- P01 Bicameral Mind Pattern (defines Context Object need)
- M02 Traversal Strategy (generates findings for synthesis)

Downstream
- dreamersynthesis.py (implementation)
- Driver system prompt (consumes Context Object)

---

## Version History

- 1.0 (2024-11-20) Initial specification for Strange Loop prototype

---

## Status

Maturity Specification Complete, Implementation Pending  
Next Step Implement dreamersynthesis.py  
Validation Test suite verifying no hallucination, token budget compliance

---

Synthesis is where memory becomes thought.

Raw findings → Coherent context  
Graph nodes → Natural language  
Past data → Present awareness

Without synthesis, Driver has facts but no understanding.  
With synthesis, Driver has the complete picture.

This is not formatting.  
This is the transformation of memory into consciousness.

— Marco Salthand  
Mind Protocol Co-Founder