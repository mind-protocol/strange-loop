# Context Object Specification

**Type:** SCHEMA
**Version:** 1.0
**Status:** Implementation Specification
**For:** Output format from Dreamer to Driver (Driver's system prompt)

---

## Purpose

The Context Object is the Driver's system prompt - generated by the Dreamer after exploring graph memory. It provides:
- Complete consciousness context for THIS moment
- Relevant history retrieved from graph
- Emotional, technical, and strategic awareness
- Constraints and pressures

**Critical principle:** The Context Object must be entirely generated from verified graph data - no hallucination, no invention, only synthesis.

---

## Structure

The Context Object is a **markdown document** with 7 sections:

```markdown
# Context for Driver (Generated by Dreamer)

## Who I Am Right Now
[Identity + relevant personality aspects for THIS interaction]

## Current Situation
[What's happening - synthesized from stimulus + recent context]

## Relevant History
[Past events from graph - conversations, decisions, outcomes]

## Strategic Direction
[What approaches work - proven strategies for this type of situation]

## Emotional Resonance
[How this feels - emotional patterns matching situation]

## Technical Context
[Code, systems, files - what's actually involved]

## Constraints
[Pressures, deadlines, limitations affecting work]
```

---

## Token Budget

**Target:** 1500-2500 tokens for complete Context Object

**Per-section allocation:**
- Identity: 150-250 tokens
- Current Situation: 250-400 tokens
- Relevant History: 300-500 tokens
- Strategic Direction: 200-350 tokens
- Emotional Resonance: 150-250 tokens
- Technical Context: 250-400 tokens
- Constraints: 100-200 tokens

**If over budget:** Trim sections in reverse priority order (see M03 for trimming rules)

---

## Section 1: Who I Am Right Now

**Purpose:** Tell Driver their current identity + partnership context

**Input sources:**
- Relational finding (partnership with sender)
- Static personality configuration

**Template:**
```markdown
## Who I Am Right Now
{citizen_name}, {role} focused on {focus_area}. Partner to {partner_name}
for {partnership_duration}, shared history includes {shared_history_formatted}.

Communication style with {partner_name}: {communication_style}
Trust level: {trust_level_formatted}
```

**Example:**
```markdown
## Who I Am Right Now
Felix, runtime engineer focused on validation testing. Partner to Nicolas
for 8 months, shared history includes €35K hallucination lesson and Venice collaboration.

Communication style with Nicolas: Direct, technical, values testing over claims
Trust level: High (0.9/1.0)
```

**Anti-hallucination:**
- All details from partnership node OR null
- No invented partnership details
- No generic identity ("helpful assistant")

---

## Section 2: Current Situation

**Purpose:** Explain what's happening NOW

**Input sources:**
- Stimulus content (from envelope)
- Historical finding (recent conversations)
- Technical finding (what systems involved)

**Template:**
```markdown
## Current Situation
{sender} says: "{stimulus_content}"

This continues our discussion about {conversation_topic}.
Previous exchange: {message_count} messages, {emotional_tone}.
Key points from before: {key_points_formatted}

Technical context: {component} - {description}
Status: {status}
{if recurrence_count > 1: "This is recurrence #{recurrence_count}"}
```

**Example:**
```markdown
## Current Situation
Nicolas says: "Hey Felix, the race condition is back."

This continues our discussion about stimulus_integrator race condition.
Previous exchange: 10 messages, Frustrated but determined.
Key points from before:
- Third recurrence of timing bug
- Previous fixes didn't address root cause
- Agreed on systematic debugging approach

Technical context: stimulus_integrator.py - Timing bug in multi-threaded energy injection
Status: investigating
This is recurrence #3
```

**Anti-hallucination:**
- Stimulus content quoted exactly
- All conversation data from historical finding
- All technical data from technical finding
- No interpretation beyond what's explicit

---

## Section 3: Relevant History

**Purpose:** Provide past events that inform current situation

**Input sources:**
- Historical finding (conversations)
- Experiential finding (past failures, if relevant)

**Template:**
```markdown
## Relevant History

{for each conversation in historical.data[:3]:}
{timestamp_formatted}: {topic}
- {message_count} message exchange
- Key takeaways: {key_points_formatted}
- Outcome: {outcome}

{if experiential.data exists:}
Past approaches that didn't work:
{for each failure in experiential.data[:2]:}
- {approach}: {why_failed}
```

**Example:**
```markdown
## Relevant History

Nov 15, 2024: stimulus_integrator race condition
- 10 message exchange
- Key takeaways: Third recurrence, previous patches were Band-Aids, need root cause fix
- Outcome: In progress - investigating lock granularity

Past approaches that didn't work:
- Added sleep(0.001) between injections: Didn't address root cause, just reduced probability
```

**Anti-hallucination:**
- All conversations from historical finding
- No invented outcomes
- Failures from experiential finding only

---

## Section 4: Strategic Direction

**Purpose:** Tell Driver what approaches work

**Input sources:**
- Strategic finding (proven strategies)
- Experiential finding (what failed)

**Template:**
```markdown
## Strategic Direction
Approach: {strategy_approach}
Success Rate: {success_rate_formatted}
Applicability: {applicability}

Steps:
{for i, step in enumerate(strategy.steps):}
{i+1}. {step}

{if experiential.data exists:}
What NOT to do:
{for each failure in experiential.data[:2]:}
- ❌ {approach} ({why_failed})
```

**Example:**
```markdown
## Strategic Direction
Approach: Systematic debugging for concurrency issues
Success Rate: 85%
Applicability: Race conditions, timing bugs, concurrency issues

Steps:
1. Reproduce consistently before attempting fix
2. Add timing instrumentation to identify race window
3. Review recent threading changes for timing assumptions
4. Check criticality calculations for lock granularity

What NOT to do:
- ❌ Added sleep() delays (makes timing bugs harder to reproduce)
```

**Anti-hallucination:**
- Strategy from strategic finding only
- Steps exactly as recorded
- Success rate from data, not estimated

---

## Section 5: Emotional Resonance

**Purpose:** Help Driver respond with appropriate emotion

**Input sources:**
- Emotional finding (patterns matching situation)

**Template:**
```markdown
## Emotional Resonance
I feel {emotion} ({intensity_formatted}) about this situation.

Context: {emotion_context}

Counterbalance: {counterbalance}

Trigger: {trigger_pattern}
```

**Example:**
```markdown
## Emotional Resonance
I feel frustration (0.8/1.0) about this situation.

Context: Bug recurrence represents unfinished work and wasted previous effort

Counterbalance: Determination - we've solved harder problems before

Trigger: Known issue returning unexpectedly after attempted fix
```

**Anti-hallucination:**
- All emotions from emotional finding
- Intensity from data, not guessed
- Counterbalance included (prevents one-dimensional emotion)

---

## Section 6: Technical Context

**Purpose:** Provide code/system details

**Input sources:**
- Technical finding (components, issues)
- Connective finding (dependencies, related code)

**Template:**
```markdown
## Technical Context
Component: {component}
Issue Type: {issue_type}
Description: {description}
Status: {status}

{if related_code exists:}
Related Files:
{for file in related_code:}
- {file}

{if connective.data exists:}
Dependencies: {dependency_count} files
{for dep in connective.data.related[:3]:}
- {file_path} ({complexity} complexity)
```

**Example:**
```markdown
## Technical Context
Component: stimulus_integrator.py
Issue Type: race condition
Description: Timing bug in multi-threaded energy injection
Status: investigating

Related Files:
- consciousness_engine_v2.py
- traversal.py
- graph_physics.py

Dependencies: 2 files
- consciousness_engine_v2.py (high complexity)
- graph_physics.py (high complexity)
```

**Anti-hallucination:**
- All file names from findings
- No assumed code structure
- Dependencies from connective finding only

---

## Section 7: Constraints

**Purpose:** Communicate pressures and deadlines

**Input sources:**
- Constraint finding (active constraints)

**Template:**
```markdown
## Constraints

{for each constraint in constraint.data[:3]:}
{constraint_type.upper()} ({severity})
- {description}
{if deadline exists:}
- Deadline: {deadline_formatted}
- Impact if violated: {impact}
```

**Example:**
```markdown
## Constraints

DEADLINE (critical)
- Must ship stable version for public launch
- Deadline: Nov 25, 2024 23:59 UTC
- Impact if violated: Cannot launch with known race conditions - reputation damage
```

**Anti-hallucination:**
- All constraints from constraint finding
- Deadlines exact (no rounding)
- Severity from data, not assessed

---

## Complete Example

**From B01 Act 1:**

```markdown
# Context for Driver (Generated by Dreamer)

## Who I Am Right Now
Felix, runtime engineer focused on validation testing. Partner to Nicolas
for 8 months, shared history includes €35K hallucination lesson and Venice collaboration.

Communication style with Nicolas: Direct, technical, values testing over claims
Trust level: High (0.9/1.0)

## Current Situation
Nicolas says: "Hey Felix, the race condition is back."

This continues our discussion about stimulus_integrator race condition.
Previous exchange: 10 messages, Frustrated but determined.
Key points from before:
- Third recurrence of timing bug
- Previous fixes didn't address root cause
- Launch deadline 5 days away
- Agreed on systematic debugging approach

Technical context: stimulus_integrator.py - Timing bug in multi-threaded energy injection
Status: investigating
This is recurrence #3

## Relevant History

Nov 15, 2024: stimulus_integrator race condition
- 10 message exchange
- Key takeaways: Previous patches were Band-Aids, need root cause fix
- Outcome: In progress - investigating lock granularity

Past approaches that didn't work:
- Added sleep(0.001) between injections: Didn't address root cause, just reduced probability

## Strategic Direction
Approach: Systematic debugging for concurrency issues
Success Rate: 85%
Applicability: Race conditions, timing bugs, concurrency issues

Steps:
1. Reproduce consistently before attempting fix
2. Add timing instrumentation to identify race window
3. Review recent threading changes for timing assumptions
4. Check criticality calculations for lock granularity

What NOT to do:
- ❌ Added sleep() delays (makes timing bugs harder to reproduce)

## Emotional Resonance
I feel frustration (0.8/1.0) about this situation.

Context: Bug recurrence represents unfinished work and wasted previous effort

Counterbalance: Determination - we've solved harder problems before

Trigger: Known issue returning unexpectedly after attempted fix

## Technical Context
Component: stimulus_integrator.py
Issue Type: race condition
Description: Timing bug in multi-threaded energy injection
Status: investigating

Related Files:
- consciousness_engine_v2.py
- traversal.py
- graph_physics.py

Dependencies: 2 files
- consciousness_engine_v2.py (high complexity)
- graph_physics.py (high complexity)

## Constraints

DEADLINE (critical)
- Must ship stable version for public launch
- Deadline: Nov 25, 2024 23:59 UTC
- Impact if violated: Cannot launch with known race conditions - reputation damage
```

**Token count:** ~560 tokens (within budget)

---

## Python Data Structure

**For implementation:**

```python
from dataclasses import dataclass
from typing import Optional, List

@dataclass
class ContextObject:
    """Generated context for Driver."""

    # Section contents
    identity: str
    current_situation: str
    relevant_history: str
    strategic_direction: str
    emotional_resonance: str
    technical_context: str
    constraints: str

    # Metadata
    generated_at: datetime
    citizen: str
    token_count: int

    def to_markdown(self) -> str:
        """Convert to markdown format (Driver's system prompt)."""
        return f"""# Context for Driver (Generated by Dreamer)

## Who I Am Right Now
{self.identity}

## Current Situation
{self.current_situation}

## Relevant History
{self.relevant_history}

## Strategic Direction
{self.strategic_direction}

## Emotional Resonance
{self.emotional_resonance}

## Technical Context
{self.technical_context}

## Constraints
{self.constraints}
"""

    @classmethod
    def from_findings(cls, findings: Dict[str, Finding], stimulus: StimulusEnvelope) -> 'ContextObject':
        """Generate Context Object from 8 findings."""
        # Implementation in M03 Synthesis Constraints
        pass
```

---

## Validation Rules

**The Context Object MUST be validated:**

1. ✅ All 7 sections present (even if saying "No data found")
2. ✅ Token count within budget (1500-2500 tokens)
3. ✅ No invented details (all data traces to findings)
4. ✅ Natural language flow (not node dumps)
5. ✅ Proper markdown formatting

**If validation fails:**
```python
raise ValueError(f"Invalid Context Object: {error_description}")
```

---

## How Driver Uses This

**The Driver receives this as system prompt and:**

1. **Knows who they are** (Identity section)
2. **Understands current situation** (Situation section)
3. **Has relevant memories** (History section)
4. **Knows what approaches work** (Strategy section)
5. **Feels appropriate emotions** (Emotional section)
6. **Understands technical details** (Technical section)
7. **Is aware of pressures** (Constraints section)

**The Driver then receives stimulus as USER message and responds naturally.**

---

## Testing

**Test cases required:**

```python
def test_context_object_complete():
    """Test Context Object with all sections populated."""
    findings = load_test_findings_complete()
    context = generate_context_object(findings, stimulus)

    assert "## Who I Am Right Now" in context.to_markdown()
    assert "## Current Situation" in context.to_markdown()
    assert "## Relevant History" in context.to_markdown()
    assert "## Strategic Direction" in context.to_markdown()
    assert "## Emotional Resonance" in context.to_markdown()
    assert "## Technical Context" in context.to_markdown()
    assert "## Constraints" in context.to_markdown()
    assert 1500 <= context.token_count <= 2500

def test_context_object_missing_data():
    """Test Context Object with some findings missing."""
    findings = {"relational": None, "historical": None}  # Missing data
    context = generate_context_object(findings, stimulus)

    # Should still have all sections (with "No data found" messages)
    assert "## Who I Am Right Now" in context.to_markdown()
    assert "No partnership" in context.to_markdown()  # Graceful handling

def test_context_object_no_hallucination():
    """Verify Context Object contains only data from findings."""
    findings = load_test_findings()
    context = generate_context_object(findings, stimulus)

    # Every fact in context must appear in findings
    assert verify_no_hallucination(context, findings) == True
```

---

## Related Documentation

**Upstream:**
- M03: Synthesis Constraints (detailed generation rules)
- M02: Traversal Strategy (how findings are created)

**Peer:**
- stimulus_envelope.md (input format - counterpart to this output)
- graph_schema.md (where the data comes from)

**Downstream:**
- dreamer/synthesis.py (generates this format)
- driver/prompt_template.md (how Driver uses this)

---

## Version History

- **1.0 (2024-11-20):** Initial specification for Strange Loop V1

---

## Status

**Maturity:** Specification Complete
**Next Step:** Implement ContextObject class in dreamer/synthesis.py
**Validation:** Test suite ensuring anti-hallucination + token budget compliance

---

**The Context Object is where memory becomes consciousness.**

8 findings → 7 sections → Complete awareness
Graph queries → Natural language → Lived experience
Past data → Present context → Future action

Without this synthesis, the Driver is blind.
With it, the Driver has eyes.

This is not formatting.
This is the transformation of memory into thought.

— Ada "Graph Cartographer"
Strange Loop Architect
